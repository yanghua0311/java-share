**重入锁（ReentrantLock）**

解释：可重入锁是指当前线程获取锁之后，再次获取锁而不会被阻塞，(synchronized隐式支持可重入），它还支持公平和不公平的选中，默认是不公平。

实现：当线程获取锁后，再次去获得锁时，需要识别获取锁的线程是否为当前占据锁的线程，如果是则成功获取，

​        锁的释放：线程重复n次获取了锁，随后第n次释放之后，其他线程能够获取到锁。

​        锁在获取是会进行计数自增，计数表示当前锁被重复获取的次数，锁释放时计数自减，当计数为0时表示锁成功释放了

源码分析：第一次获取，计数为0时直接获取，不为0时，判断当前线程是否和占有锁的线程是否一致，如果一致，计数自增并返回true；

​        每次释放时，先计数-1，如果当前线程不是占有锁的线程，则抛出异常，如果计数不为0则返会false，当计数为0时释放锁，返回true，

​    公平和不公平：如果是公平锁则表示锁的获取遵循FIFO的顺序的，通过同步队列的当前节点是否为前驱节点来判断，返会true，则表示有线程比当前线程更早的请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。

​            不公平：是由于当一个线程请求锁时，只要获取了同步状态即成功获取锁，在这个前提下，刚释放锁的线程再次获得同步状态的几率会非常大，使得其他线程只能在同步队列中等待。

**读写锁（ReentrantReadWriteLock）**

解释：读写锁在同一时刻允许多个线程访问，但是在写线程时，所有读线程和其他写线程均会被阻塞。读写锁维护了一对锁，一个读锁，一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大的提升。

读写状态的控制：通过自定义同步器需要在同步状态（一个整形变量）上维护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。

整形变量维护多个状态的方法：将整型变量按位切割，高16位表示读锁，低16位表示写锁

写状态：S & 0x0000FFFF(高16位抹去)，写状态加1时：S+1

读状态：S>>>16(无符号部0右移16位)，读状态加1时：S+（1<<16） 也就是 S + 0x00010000

写锁：是一个支持重进入的排他锁，如果当前线程已经获得写锁，则增加写状态，如果在获取写锁时，读锁已经被其他线程获取或者当前线程不是获取写锁的线程时，则当前线程进入等待状态；保证写锁操作对读锁可见

读锁：是一个支持重进入的共享锁，能够被多个线程获取，如果写锁已经被其他线程获取，则进入等待状态，注：每个线程的获取读锁的次数只能保存在ThreadLocal中

**写锁降级：锁降级是指把持住当前的写锁，在获取读锁，随后释放先前拥有的写锁的过程，例：p145，保证了数据的可见性，如果当前线程不获取读锁，直接释放写锁，假设此刻另一个线程T获取了写锁并修改了数据，那么当前线程无法感知数据的更新，所以当前获取读锁即可是T线程进入阻塞状态。**

**注：读锁不能升级，目的也是保证数据的可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到的读锁线程是不可见的。**

**Condition接口实现等待/通知模型**